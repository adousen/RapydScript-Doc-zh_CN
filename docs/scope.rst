=========================
变量的作用域
=========================

.. contents:: 目录

------------------

局部和全局作用域
------------------

作用域与变量的上下文环境有关。例如，在函数内部定义的变量对函数外部的代码是不可见的，这个变量的作用域只在函数的局部范围。

JavaScript控制作用域是通过 ``var`` 关键字。若变量未以var关键字开头进行声明，则会引用离其最近的同名变量。例如下面的JavaScript代码不仅仅返回加1后的 ``a`` ，而且还会将全局变量 ``a`` 的值变为 ``a+1`` ：

.. code-block:: javascript

    var a = 1;
    var a_plus_1 = function() {
        return ++a;
    };

通常来说，如果你省略 ``var`` ，JavaScript就会默认在外部或者全局作用域中查找。然而，在一些大型程序中，这种方式会引入一些复杂的bug。为了避免这个问题，RapydScript的作用域采取了完全相反的工作方式（与Python相似）。RapydScript偏向于局部作用域优先的方式，无论你用何种方式在函数中为变量赋值，总是会创建一个局部的变量（这被称为局部变量隐藏全局变量）。这会带来另一个烦恼，那就是变量的修改将被舍弃。例如下面的代码，乍看起来变量 ``a`` 的值会变成2： :: 

    a = 1
    b = 1
    increment = def():
        a += b
    increment()

但执行之后，你会发现 increment() 函数会舍弃所有对变量 `a` 的修改。这是因为与Python一样，RapydScript默认地并不允许你对外部作用域中声明的变量进行修改。只要你是在内部作用域中对变量 ``a`` 进行赋值，那么RapydScript就会将其定义为一个内部变量，并且隐藏外部作用域的同名变量 ``a`` 。

global和nonlocal
------------------

有一个解决的办法是使用 ``global`` 关键字，将 ``a`` 声明为一个全局变量。并且，在每个打算对 ``a`` 进行修改的函数中都需要这样。

但是这种方式还是会造成对全局作用域的污染，因为可能会不小心就覆盖了不相干的同名变量（比如他人定义的或者来自其他库的变量）。RapydScript通过引入 ``nonlocal`` 关键字解决了这个问题（类似Python3）： :: 

    a = 1
    b = 1
    increment = def():
        nonlocal a
        a += b
    increment()

需要注意的是，上面的代码中变量 ``b`` 并不会被隐藏。因为只有赋值操作才会触发隐藏，你可以在不使用 ``nonlocal`` 的情况下，读取到外部作用域的变量。

你可以通过用逗号隔开的方式，联合声明多个非局部变量： ``nonlocal a, b, c`` 。此外，你还可以通过链式 ``nonlocal`` 声明，跳出到多个作用域： :: 

    def fun1():
        a = 5
        b = fun2():
            nonlocal a
            a *= 2
            c = fun3():
                nonlocal a
                a += 1

在大多数情况下，变量隐藏是值得采用的方式，因为它不会造成对外部逻辑的意外破坏。并且一般来讲，如果你想要对外部作用域中的变量进行修改，更好的方式是将函数的返回值赋给它。尽管如此，但是在某些情况下，使用 ``nonlocal`` 可以使代码更加清新。当然也可以使用 ``global`` ,但这并不是一个好的方案，使用 ``nonlocal`` 会更好。

































