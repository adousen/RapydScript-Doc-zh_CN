===================
编程琐事
===================

.. contents:: 目录

------------------

注意事项
------------------

在完美世界中，程序的运行没有缺陷，并且没有要绕着用户转的的情况。在不是怎么完美的世界，程序的怪异之处都是由其本身造成，并且都还可以被修复。但在我们的真实世界，不仅要处理程序本身的一些奇怪，还要面对与之关联的程序出现的问题。RapydScript自然不能独善其身，它不仅本身有许多不足之处，而且还有一些由浏览器产生的问题，以及jQuery等外部库产生的bug。下面列出了一些我们需要注意的事情：

 - RapydScript会自动给由其生成得类添加 ``new`` 关键字。而例如 ``Image`` 和 ``RegExp`` 等原生的JavaScript对象，以及来自外部库的类，均需要标明为external。这意味着从对外部引入的、不能被编译器识别的类需要使用 ``@external`` 装饰器。不然，你就需要手动添加 ``new`` 关键字。

 - 自动附加new关键字取决于编译器是否能够识别出类。由于JavaScript属于动态语言，因此RapydScript不能够100%准确做到这一点（这通常是由于JavaScript代码采用的是鸭子类型，即将类的构造函数隐藏于变量中），这些时候你得自己添加 ``new`` 关键字。类似的，RapydScript编译器会尝试将SomeClass.method()转换成SomeClass.prototype.method()，但是有些时候却会失败。不过，对外部类使用 ``@external`` 装饰器作声明可以解决这个问题。

 - JavaScript的相等操作符的适用范围比较有限，只有使用在原生数据类型（String,number,boolean）上时比较正常。而使用在对象上时，则与Python的 **is** 操作符更加接近，即比较的是对象的内存地址而不是值。因此，在RapydScript中不要对数组或者对象使用 ``==`` ，建议使用内建的 ``deep_eq`` 函数。

 - 在JavaScript中为 **True** 的，在Python中可能就完全不是这么回事。空列表或字典在python中会被看作 ``False``，但在JavaScript中却会被看作 ``True`` 。尽管RapydScript编译器可以如此设计，但会付出很大的性能代价。因此，在遇到这种情况时，你最好还是选择检查它们的长度而不是直对对象做判断。

 - 在RS中，方法与对象的绑定不是自动的。所以，``someobj.somemethod()`` 的运行结果是正确的，但是 ``x = someobj.somethod; x()`` 就不是了。不过，RS还是可以做到，但是性能代价会很大。可以查看前面章节中关于方法绑定部分进行了解。此外，你还可以在编译中使用 ``--auto-bind`` 标志，使得方法可以自动绑定到对象，但请记得千万别抱怨性能受到影响。

 - 由于jQuery错误地认为其他代码不会对JavaScript中 ``Object`` 做任何的修改，因而在其代码多个本应该做检查的地方却并没有使用 ``object.hasOwnProperty()`` 。为了与共同工作时不出错误，在编写stdlib库代码时，我特意将字典的方法放在了别的对象之下(dict)。正常的Python程序是允许你使用 ``hash.keys()`` 或者 ``dict.keys(hash)`` 两种方式。但是，RapydScript选择了只支持第二种语法，这是不得已而为之。

 - 负号索引只支持常数。一般来讲，如果编译器发现你使用的是负号索引（比如 ``array[-n]`` ），那么它会将其转换成 ``array[array.length-n]`` 。但如果负号后面是一个索引值的变量，那么你需要手动将其进行正确的索引值转换。

 - 操作符重载目前还不被支持



















































